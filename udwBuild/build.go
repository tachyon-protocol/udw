package udwBuild

import (
	"fmt"
	"github.com/tachyon-protocol/udw/udwFile"
	"github.com/tachyon-protocol/udw/udwGoSource/udwGoBuild"
	"github.com/tachyon-protocol/udw/udwGoSource/udwGoImport"
	"github.com/tachyon-protocol/udw/udwGoSource/udwGoWriter"
	"github.com/tachyon-protocol/udw/udwGoSource/udwGoWriter/udwGoTypeMarshal"
	"github.com/tachyon-protocol/udw/udwStrconv"
	"github.com/tachyon-protocol/udw/udwTime"
	"path"
	"path/filepath"
	"sort"
	"strconv"
	"strings"
	"time"
)

const debugTime = false
const debugSubProcessTime = false
const debugBuildDep = false

func MustBuild() {
	var startTime time.Time
	if debugTime || debugSubProcessTime {
		startTime = time.Now()
	}
	udwFile.MustDelete("src/make/tpl/BuildCmd")
	udwFile.MustCheckContentAndWriteFileWithMkdir("src/tmp/.gitignore", []byte("*"))
	basePath := udwFile.MustGetFullPath("src")
	originPkgDirFullPathList := []string{}
	originPkgAbsPathList := []string{}
	genPkgToOriginPkgPathMap := map[string]string{}
	dirList := udwFile.MustGetAllDir(basePath)
	if debugTime {
		fmt.Println("mzyzpwbykp after MustGetAllDir", udwTime.DurationFormat(time.Since(startTime)))
	}
	for _, dir := range dirList {
		if !strings.HasSuffix(dir, "_Build") {
			continue
		}

		if strings.Contains(dir, ".backup") {
			continue
		}
		originPkgDirFullPathList = append(originPkgDirFullPathList, dir)
		absPkgImport := udwFile.MustGetRelativePath(basePath, dir)
		absPkgImport = strings.Replace(absPkgImport, `\`, `/`, -1)
		originPkgAbsPathList = append(originPkgAbsPathList, absPkgImport)
		absPkgImportDir := path.Dir(absPkgImport)
		if strings.TrimSuffix(path.Base(absPkgImport), "_Build") == path.Base(absPkgImportDir) {

			genPkgToOriginPkgPathMap[absPkgImportDir] = absPkgImport
		}

	}
	if debugTime {
		fmt.Println("mzyzpwbykp after genPkgToOriginPkgPathMap", udwTime.DurationFormat(time.Since(startTime)))
	}
	pkgToUpLevelPkgMap := map[string][]string{}
	goImportResp := udwGoImport.MustMulitGetPackageImport(udwGoImport.MustMulitGetPackageImportRequest{
		AbsImportPathList:            originPkgAbsPathList,
		SimpleGoPathDirSearchNoError: true,
	})

	for _, absImportPath := range originPkgAbsPathList {
		pkgToUpLevelPkgMap[absImportPath] = []string{}
		thisAbsImportPathList := goImportResp.GetAllLevelImportPathList(absImportPath)
		for _, thisAbsImportPath := range thisAbsImportPathList {
			if thisAbsImportPath == absImportPath {
				continue
			}
			buildPkgImportPath := genPkgToOriginPkgPathMap[thisAbsImportPath]
			if buildPkgImportPath == "" {
				continue
			}
			if buildPkgImportPath == absImportPath {

				continue
			}
			if debugBuildDep {
				fmt.Println("83vph8dp5z debugBuildDep", absImportPath, buildPkgImportPath)
			}
			pkgToUpLevelPkgMap[absImportPath] = append(pkgToUpLevelPkgMap[absImportPath], buildPkgImportPath)
		}
	}
	if debugTime {
		fmt.Println("mzyzpwbykp after MustMulitGetPackageImport", udwTime.DurationFormat(time.Since(startTime)))
	}

	hasGenPkgSet := map[string]bool{}
	genMark := 0
	f := func(pkgPathList []string) {
		sort.Strings(pkgPathList)
		goFile := udwGoWriter.NewGoFileContext("main")
		if debugSubProcessTime {
			goFile.AddImportPathList([]string{"time"})
		}
		goFile.Buf.WriteString(`// this file is generated by github.com/tachyon-protocol/udw/udwBuild ,please do not edit it.
// you can read document at src/github.com/tachyon-protocol/udw/udwBuild/build.go:13 to learn how to use it.

func main(){
`)
		if debugSubProcessTime {
			timeUnixNano := startTime.UnixNano()
			goFile.Buf.WriteString(`_startTime:=time.Unix(` + strconv.Itoa(int(timeUnixNano/1e9)) + `,` + strconv.Itoa(int(timeUnixNano%1e9)) + `);
	println("mzyzpwbykp tpl process start",time.Since(_startTime).String())
`)
		}
		tagList := TagGetList()
		if len(tagList) > 0 {
			goFile.AddImportPath("github.com/tachyon-protocol/udw/udwBuild")
			goFile.Buf.WriteString(`udwBuild.TagAdd(`)
			for _, tag := range tagList {
				goFile.Buf.WriteString(udwGoTypeMarshal.MustWriteObjectToMainPackage(tag))
				goFile.Buf.WriteByte(',')
			}
			goFile.Buf.WriteString(`)
`)
		}
		for i, pkgPath := range pkgPathList {
			hasGenPkgSet[pkgPath] = true

			aliasPkgName := filepath.Base(pkgPath) + "_" + strconv.Itoa(i)
			goFile.Buf.WriteString(aliasPkgName)
			goFile.Buf.WriteString(".UdwBuild()\n")
			goFile.AddImportPathWithAlias(strings.Replace(pkgPath, "\\", "/", -1), aliasPkgName)
			if debugSubProcessTime {
				goFile.Buf.WriteString(`println(` + udwGoTypeMarshal.MustWriteObjectToMainPackage(`"mzyzpwbykp after `+pkgPath) + `,time.Since(_startTime).String())` + "\n")
			}
		}
		goFile.Buf.WriteString("}")

		buildPkgName := "udwBuild_" + udwStrconv.FormatInt(genMark)
		goFile.MustWriteFileWithSelfBuffer("src/tmp/" + buildPkgName + "/main__Gen.go")
		if debugTime {
			fmt.Println("mzyzpwbykp before runCmd", time.Since(startTime).String())
		}
		gorunPkgPath("tmp/" + buildPkgName)
		if debugTime {
			fmt.Println("mzyzpwbykp after runCmd", time.Since(startTime).String())
		}
		genMark++
	}

	pkgPathList := []string{}
	for {
		pkgPathList = pkgPathList[:0]
	for1:
		for key, list := range pkgToUpLevelPkgMap {
			if hasGenPkgSet[key] {
				continue
			}
			for _, im := range list {
				if !hasGenPkgSet[im] {
					continue for1
				}
			}
			pkgPathList = append(pkgPathList, key)
		}
		if len(pkgPathList) == 0 {
			break
		}
		f(pkgPathList)
	}
	if len(pkgToUpLevelPkgMap) != len(hasGenPkgSet) {
		for one, val := range pkgToUpLevelPkgMap {
			if !hasGenPkgSet[one] {
				fmt.Println("ak27xjjwyk", one, val)
			}
		}
		panic("build import circle")
	}
}

func gorunPkgPath(pkgPath string) {
	udwGoBuild.MustGoRunSimple(pkgPath, nil)

}
